text(seasons, ratings, cex=0.6, pos=4, col="red")
plot(seasons, ratings, "l", main="Ratings (Season Wise)", ylab = "Ratings", xlab = "Season", pch=18, col="blue")
text(seasons, ratings, cex=0.6, pos=4, col="red")
plot(seasons, ratings, "b", main="Ratings (Season Wise)", ylab = "Ratings", xlab = "Season", pch=18, col="blue")
text(seasons, ratings, cex=0.6, pos=4, col="red")
plot(seasons, ratings, "b", main="Ratings (Season Wise)", ylab = "Ratings", xlab = "Season", pch=18, col="blue")
plot(seasons, ratings, "b", main="Ratings (Season Wise)", ylab = "Ratings", xlab = "Season", pch=18, col="blue")
text(ratings, cex=0.6, pos=4, col="red")
plot(seasons, ratings, "b", main="Ratings (Season Wise)", ylab = "Ratings", xlab = "Season", pch=18, col="blue")
text(seasons, ratings, ratings, cex=0.6, pos=4, col="red")
earthquakes.dat <- read.delim("/Users/vikrambahadur/Downloads/earthquakes.txt")
View(earthquakes.dat)
View(earthquakes.dat)
y.dat=earthquakes.dat$Quakes[1:100]
y.new=earthquakes.dat$Quakes[101:103]
covid.dat <- read.delim("/Users/vikrambahadur/Downloads/GoogleSearchIndex.txt")
covid.dat$Week=as.Date(covid.dat$Week,format = '%Y-%m-%d')
library(readr)
library(sfdep)
require(sp)
install.packages("sp")
require(spdep)
install.packages("sfdep")
install.packages("spdep")
install.packages("spdep")
install.packages("readr")
install.packages("ggplot2")
install.packages("ggthemes")
library(sf)
data_municipalities <- read_csv("../data/data_municipalities.csv")
library(sf)
library(sfdep)
library(sp)
library(spdep)
library(readr)
library(ggplot2)
library(ggthemes)
data_municipalities <- read_csv("../data/data_municipalities.csv")
library(dplyr)
install.packages("dplyr")
library(dplyr)
library(sf)
library(sfdep)
library(sp)
library(spdep)
library(readr)
library(ggplot2)
library(ggthemes)
data_municipalities <- read_csv("../data/data_municipalities.csv")
data_municipalities <- read_csv("/Users/vikrambahadur/reproducible_research/EC2024/EC2024/data/data_municipalities.csv")
map_municipalities <- st_read("/Users/vikrambahadur/reproducible_research/EC2024/EC2024/data/shapefile/map_municipalities.shp")
map_municipalities <- st_read("/Users/vikrambahadur/reproducible_research/EC2024/EC2024/data/shapefile/map_municipalities.shp")
plot(st_geometry(map_municipalities))
which(!map_municipalities$mncplty_c %in% data_municipalities$municipality_code)
which(!data_municipalities$municipality_code %in% map_municipalities$mncplty_c )
map_municipalities_with_data <-
map_municipalities %>%
left_join(data_municipalities,
by = join_by(mncplty_c == municipality_code))
ggplot(map_municipalities_with_data,
aes(fill = percent_vaccinated)) +
geom_sf() +
ggthemes::theme_map() +
scale_fill_continuous()
map_partitions <- st_read("../_data/shapefile/map_partitions.shp")
map_partitions <- st_read("/Users/vikrambahadur/reproducible_research/EC2024/EC2024/data/shapefile/map_partitions.shp")
ggplot() +
geom_sf(data = map_partitions,
aes(fill = partition)) +
ggthemes::theme_map()
ggplot() +
geom_sf(data = map_municipalities_with_data,
aes(fill = percent_vaccinated)) +
ggthemes::theme_map() +
scale_fill_continuous() +
geom_sf(data = map_partitions,
size = 2,
color = "red",
fill = NA)
#---------------------------------------------------------------
# creating spatial weight matrix - contiguity (i.e. common border)
municipalities_neighbours <- sfdep::st_contiguity(map_municipalities)
# lets check its structure
glimpse(municipalities_neighbours)
# converting a list of neighbours into a matrix
spatial_weights <- nb2mat(municipalities_neighbours)
# you can check if it is row standardized by default
summary(rowSums(spatial_weights))
map_municipalities_with_data$splag_percent_vaccinated <-
spatial_weights %*% as.matrix(map_municipalities_with_data$percent_vaccinated)
View(map_partitions)
ggplot() +
geom_sf(data = map_partitions,
aes(fill = partition)) +
ggthemes::theme_map()
load("../Data/got/season_1.RData")
View(season_data)
accuracy(forecasts_without_reestimation, log_transformed_1966)
# Main R script
## Required libraries
library(xts)
library(quantmod)
library(ggthemes)
library(dygraphs)
library(tidyverse)
library(urca)
library(tseries)
library(forecast)
library(dplyr)
## Clean any local/environment variables
rm(list = ls())
## Get this script present location
LOC_CODE = dirname(rstudioapi::getSourceEditorContext()$path)
print(LOC_CODE)
## Set it to working direcotry
setwd(LOC_CODE)
## Read bitcoin csv daily price
# quotes_bitcoin <- read_csv("../data/Bitcoin_01_01_2012-04_10_2018_historical_data_coinmarketcap.csv",
# col_select = c(timeOpen,close))
quotes_bitcoin <- read_csv("../data/Bitcoindata.csv",
col_select = c(Date,High))
colnames(quotes_bitcoin)[2] <- "Close"
#quotes_bitcoin$Close <- quotes_bitcoin$High
## We can examine structure of the resulting object:
head(quotes_bitcoin)
tail(quotes_bitcoin)
glimpse(quotes_bitcoin)
## Let’s also check the class of the Date column:
class(quotes_bitcoin$Close)
## lets check structure of the whole dataset
str(quotes_bitcoin)
##Let's transform timeOpen into date:
quotes_bitcoin$Date <- as.Date(quotes_bitcoin$Date, format = "%d/%m/%Y")
## We have to give the format in which date is originally stored: * %y means 2-digit year, * %Y means 4-digit year * %m means a month * %d means a day
class(quotes_bitcoin$Date)
head(quotes_bitcoin)
glimpse(quotes_bitcoin)
## Creating xts objects
quotes_bitcoin <-
xts(quotes_bitcoin[, -1], # data columns (without the first column with date)
quotes_bitcoin$Date)  # date/time index
# Lets see the result:
head(quotes_bitcoin)
str(quotes_bitcoin)
## Finally, let’s use the ggplot2 package to produce nice visualization.
## The ggplot2 package expects data to be in long format, rather than wide format.
## Hence, first we have to convert the tibble to a long tibble:
## Plotting Actual Bitcoin Price
tibble(df = quotes_bitcoin) %>%
ggplot(aes(zoo::index(quotes_bitcoin), df)) +
geom_line() +
theme_bw() +
scale_x_date(date_breaks = "1 year", date_labels = "%b-%Y")+
labs(
title = "Actual Bitcoin Price",
subtitle = paste0("Number of observations: ", length(quotes_bitcoin)),
caption = "source: RR 2024",
x="",
y=""
)
## Plotting Log Transformed Bitcoin Price
tibble(df = quotes_bitcoin) %>%
ggplot(aes(zoo::index(quotes_bitcoin), log(quotes_bitcoin))) +
geom_line() +
theme_bw() +
scale_x_date(date_breaks = "1 year", date_labels = "%b-%Y")+
labs(
title = "Log Transformed Bitcoin Price",
subtitle = paste0("Number of observations: ", length(quotes_bitcoin)),
caption = "source: RR 2024",
x="",
y=""
)
## Plotting 1st Difference Log Operator
tibble(df = quotes_bitcoin) %>%
ggplot(aes(zoo::index(quotes_bitcoin), periodReturn(quotes_bitcoin, period="daily", type="log"))) +
geom_line() +
theme_bw() +
scale_x_date(date_breaks = "1 year", date_labels = "%b-%Y")+
labs(
title = "1st Difference Log Operator",
subtitle = paste0("Number of observations: ", length(quotes_bitcoin)),
caption = "source: RR 2024",
x="",
y=""
)
selectIndex500 <- (zoo::index(quotes_bitcoin) <= as.Date("2013-05-14","%Y-%m-%d"))
original_500 <- quotes_bitcoin[selectIndex500,]
log_transformed <- log(quotes_bitcoin)
log_transformed_500 <- log_transformed[selectIndex500,]
first_diff_log_operator_500 <- periodReturn(original_500, period="daily", type="log")
adf.original_500 <- adf.test(original_500)
pp.original_500 <- pp.test(original_500)
print(adf.original_500)
print(pp.original_500)
adf.log_transformed_500 <- adf.test(log_transformed_500)
pp.log_transformed_500 <- pp.test(log_transformed_500)
print(adf.log_transformed_500)
print(pp.log_transformed_500)
adf.first_diff_log_operator_500 <- adf.test(first_diff_log_operator_500)
pp.first_diff_log_operator_500 <- pp.test(first_diff_log_operator_500)
print(adf.first_diff_log_operator_500)
print(pp.first_diff_log_operator_500)
selectIndex2000 <- (zoo::index(quotes_bitcoin) <= as.Date("2017-06-25","%Y-%m-%d"))
original_2000 <- quotes_bitcoin[selectIndex2000,]
log_transformed_2000 <- log(original_2000)
first_diff_log_operator_2000 <- periodReturn(original_2000, period="daily", type="log")
adf.original_2000 <- adf.test(original_2000)
pp.original_2000 <- pp.test(original_2000)
print(adf.original_2000)
print(pp.original_2000)
adf.log_transformed_2000 <- adf.test(log_transformed_2000)
pp.log_transformed_2000 <- pp.test(log_transformed_2000)
print(adf.log_transformed_2000)
print(pp.log_transformed_2000)
adf.first_diff_log_operator_2000 <- adf.test(first_diff_log_operator_2000)
pp.first_diff_log_operator_2000 <- pp.test(first_diff_log_operator_2000)
print(adf.first_diff_log_operator_2000)
print(pp.first_diff_log_operator_2000)
auto.arima(original_500) #Result is ARIMA(4,1,4)
########
######## Table 2 details start from here
########
arima_model_500 <- Arima(log_transformed_500$Close, order=c(4,1,0))
summary(arima_model_500) # Training Sample performance, Need to put in result
arima_model_2000 <- Arima(log_transformed_2000$Close, order=c(4,1,1))
summary(arima_model_2000) # Training Sample performance, Need to put in result
# Fit NNAR model (specify orders explicitly)
nnar_model_500 <- nnetar(log_transformed_500$Close, p=2, P=1, size=2)
accuracy(nnar_model_500)
nnar_model_2000 <- nnetar(log_transformed_2000$Close, p=1, P=2, size=2)
accuracy(nnar_model_2000)
# Forecast next 10 day with ARIMA for log_transformed_500
arima_forecast_500 <- forecast(arima_model_500, h = 10)
print(arima_forecast_500)
selectIndex510 <- (zoo::index(quotes_bitcoin) <= as.Date("2013-05-24","%Y-%m-%d"))
original_510 <- quotes_bitcoin[selectIndex510,]
log_transformed_510 <- log(original_510)
autoplot(arima_forecast_500) + autolayer(ts(log_transformed_510$Close), series="Actual")
hh <- 1966
# Create a vector to store the forecasts
forecasts_without_reestimation <- numeric(hh)
# Forecasting step-by-step without re-estimation
for (i in 1:hh) {
# Forecast the next period using the already fitted model
if (i==1) {
arima_model_500test <- Arima(log_transformed_500$Close, order=c(4,1,0))
} else {
arima_model_500test <- Arima(rbind(log_transformed_500,log(quotes_bitcoin[500+(i-1)]))$Close, order=c(4,1,0))
}
forecast_result <- forecast(arima_model_500test, h=1)
# Store the forecast for the i-th period
forecasts_without_reestimation[i] <- forecast_result$mean[1]
}
forecasts_without_reestimation_ts <- ts(forecasts_without_reestimation, start=end(quotes_bitcoin)[1] + (end(quotes_bitcoin)[2] + 1)/frequency(quotes_bitcoin), frequency=frequency(quotes_bitcoin))
accuracy(forecasts_without_reestimation, log_transformed_1966)
original_1966 <- window(quotes_bitcoin, start = "2013-05-15")
log_transformed_1966 <- log(original_1966)
accuracy(forecasts_without_reestimation, log_transformed_1966)
accuracy(ts(forecasts_without_reestimation), log_transformed_1966)
length(forecasts_without_reestimation)
autoplot(ts(forecasts_without_reestimation)) + autolayer(ts(log(quotes_bitcoin$Close)), series="Actual")
autoplot(bind(log_transformed_500,ts(forecasts_without_reestimation))) + autolayer(ts(log(quotes_bitcoin$Close)), series="Actual")
autoplot(rbind(log_transformed_500,ts(forecasts_without_reestimation))) + autolayer(ts(log(quotes_bitcoin$Close)), series="Actual")
autoplot(rbind(ts(log_transformed_500),ts(forecasts_without_reestimation))) + autolayer(ts(log(quotes_bitcoin$Close)), series="Actual")
autoplot(rbind(ts(log_transformed_500$Close),ts(forecasts_without_reestimation))) + autolayer(ts(log(quotes_bitcoin$Close)), series="Actual")
autoplot(rbind(ts(log_transformed_500$Close),ts(forecasts_without_reestimation$Close))) + autolayer(ts(log(quotes_bitcoin$Close)), series="Actual")
autoplot(forecasts_without_reestimation) + autolayer(ts(log(quotes_bitcoin$Close)), series="Actual")
autoplot(forecasts_without_reestimation) + autolayer(ts(log(quotes_bitcoin$Close)), series="Actual")
autoplot(ts(forecasts_without_reestimation)) + autolayer(ts(log(quotes_bitcoin$Close)), series="Actual")
autoplot(log_transformed_500)+autoplot(ts(forecasts_without_reestimation)) + autolayer(ts(log(quotes_bitcoin$Close)), series="Actual")
autoplot(ts(log_transformed_500))+autoplot(ts(forecasts_without_reestimation)) + autolayer(ts(log(quotes_bitcoin$Close)), series="Actual")
autoplot(ts(log_transformed_500$Close))+autoplot(ts(forecasts_without_reestimation)) + autolayer(ts(log(quotes_bitcoin$Close)), series="Actual")
autolayer(ts(log_transformed_500$Close))+autoplot(ts(forecasts_without_reestimation)) + autolayer(ts(log(quotes_bitcoin$Close)), series="Actual")
autoplot(arima_forecast_1966) + autolayer(ts(log_transformed_2010$Close), series="Actual")
autoplot(arima_forecast_2000) + autolayer(ts(log_transformed_2010$Close), series="Actual")
autoplot(arima_forecast_500) + autolayer(ts(log_transformed_510$Close), series="Actual")
length(arima_forecast_500)
length(log_transformed_510)
autoplot(ts(forecasts_without_reestimation)) + autolayer(log_transformed_1966), series="Actual")
autoplot(ts(forecasts_without_reestimation)) + autolayer(log_transformed_1966, series="Actual")
autoplot(ts(forecasts_without_reestimation)) + autolayer(ts(log_transformed_1966), series="Actual")
autolayer(ts(log(quotes_bitcoin$Close)), series="Actual")+autoplot(ts(forecasts_without_reestimation))
autoplot(ts(log(quotes_bitcoin$Close)), series="Actual")+autolayer(ts(forecasts_without_reestimation))
autoplot(ts(forecasts_without_reestimation)) + autolayer(ts(log(quotes_bitcoin$Close)), series="Actual")
autoplot(arima_forecast_500) + autolayer(ts(log_transformed_510$Close), series="Actual")
head(log(quotes_bitcoin$Close))
length(log(quotes_bitcoin$Close))
length(ts(forecasts_without_reestimation))
forecast_resulttest <- forecast(arima_model_500, h=1)
print(forecast_resulttest)
View(arima_model_500)
View(first_diff_log_operator_500)
m_test <- arima(log_transformed_500, order=c(4,1,0))
m_forecast <- forecast(m_test, h=1)
print(m_forecast)
head(log_transformed_500)
log_transformed_500
index(quotes_bitcoin)
index(quotes_bitcoin)[501]
forecasts_without_reestimation[1]
results <- data.frame(Date = integer(500), Close = integer(500))
View(results)
class(results)
hh <- 5
# Create a vector to store the forecasts
forecasts_without_reestimation <- numeric(hh)
# Forecast the next period using the already fitted model
if (i==1) {
arima_model_500test <- Arima(log_transformed_500$Close, order=c(4,1,0))
} else {
arima_model_500test <- Arima(rbind(log_transformed_500,log(quotes_bitcoin[500+(i-1)]))$Close, order=c(4,1,0))
}
View(forecast_result)
View(results)
results[1]
results[1,]
results[0,]
index(quotes_bitcoin)[500+i]
results$Date[1] <- index(quotes_bitcoin)[500+1]
results[1,]
results$Date[1] <- as.Date(index(quotes_bitcoin)[500+1])
results[1,]
results <- data.frame(Date = date(2), Close = integer(2))
results$Date[1] <- as.character.Date(index(quotes_bitcoin)[500+1])
results[1,]
hh <- 5
# Create a vector to store the forecasts
forecasts_without_reestimation <- numeric(hh)
results <- data.frame(Date = integer(500), Close = integer(500))
# Forecasting step-by-step without re-estimation
for (i in 1:hh) {
# Forecast the next period using the already fitted model
if (i==1) {
arima_model_500test <- Arima(log_transformed_500$Close, order=c(4,1,0))
} else {
arima_model_500test <- Arima(rbind(log_transformed_500,log(quotes_bitcoin[500+(i-1)]))$Close, order=c(4,1,0))
}
forecast_result <- forecast(arima_model_500test, h=1)
results$Date[i] <- as.character.Date(index(quotes_bitcoin)[500+i])
results$Close[i] <- forecast_result$mean[1]
# Store the forecast for the i-th period
forecasts_without_reestimation[i] <- forecast_result$mean[1]
}
View(results)
View(results)
result_ts <-  xts(results[, -1], results$Date)
results$Date <- as.Date(results$Date, format = "%d/%m/%Y")
result_ts <-  xts(results[, -1], results$Date)
results <- data.frame(Date = integer(5), Close = integer(5))
# Forecast the next period using the already fitted model
if (i==1) {
arima_model_500test <- Arima(log_transformed_500$Close, order=c(4,1,0))
} else {
arima_model_500test <- Arima(rbind(log_transformed_500,log(quotes_bitcoin[500+(i-1)]))$Close, order=c(4,1,0))
}
View(results)
hh <- 5
# Create a vector to store the forecasts
forecasts_without_reestimation <- numeric(hh)
results <- data.frame(Date = integer(5), Close = integer(5))
# Forecasting step-by-step without re-estimation
for (i in 1:hh) {
# Forecast the next period using the already fitted model
if (i==1) {
arima_model_500test <- Arima(log_transformed_500$Close, order=c(4,1,0))
} else {
arima_model_500test <- Arima(rbind(log_transformed_500,log(quotes_bitcoin[500+(i-1)]))$Close, order=c(4,1,0))
}
forecast_result <- forecast(arima_model_500test, h=1)
results$Date[i] <- as.character.Date(index(quotes_bitcoin)[500+i])
results$Close[i] <- forecast_result$mean[1]
# Store the forecast for the i-th period
forecasts_without_reestimation[i] <- forecast_result$mean[1]
}
View(results)
results$Date <- as.Date(results$Date, format = "%d/%m/%Y")
result_ts <-  xts(results[, -1], results$Date)
View(results)
hh <- 5
# Create a vector to store the forecasts
forecasts_without_reestimation <- numeric(hh)
results <- data.frame(Date = integer(5), Close = integer(5))
# Forecasting step-by-step without re-estimation
for (i in 1:hh) {
# Forecast the next period using the already fitted model
if (i==1) {
arima_model_500test <- Arima(log_transformed_500$Close, order=c(4,1,0))
} else {
arima_model_500test <- Arima(rbind(log_transformed_500,log(quotes_bitcoin[500+(i-1)]))$Close, order=c(4,1,0))
}
forecast_result <- forecast(arima_model_500test, h=1)
results$Date[i] <- as.character.Date(index(quotes_bitcoin)[500+i])
results$Close[i] <- forecast_result$mean[1]
# Store the forecast for the i-th period
forecasts_without_reestimation[i] <- forecast_result$mean[1]
}
View(results)
result_ts <-  xts(results[, -1], results$Date)
View(results)
View(quotes_bitcoin)
View(quotes_bitcoin)
esults$Date <- as.Date(results$Date, format = "%Y-%m-%d")
results$Date <- as.Date(results$Date, format = "%Y-%m-%d")
View(results)
result_ts <-  xts(results[, -1], results$Date)
View(result_ts)
View(quotes_bitcoin)
autoplot(result_ts) + autolayer(quotes_bitcoin, series="Actual")
autoplot(result_ts) + forecast::autolayer(quotes_bitcoin, series="Actual")
forecast::autoplot(result_ts) + forecast::autolayer(quotes_bitcoin, series="Actual")
ggplot2::autoplot(result_ts) + ggplot2::autolayer(quotes_bitcoin, series="Actual")
autoplot(result_ts) + ggplot2::autolayer(quotes_bitcoin, series="Actual")
autoplot(result_ts) + ggplot2::autolayer(quotes_bitcoin, series="Actual")
autoplot(result_ts) + autolayer(quotes_bitcoin, series="Actual")
autoplot(result_ts)
autoplot(quotes_bitcoin)
autoplot(result_ts)+autoplot(quotes_bitcoin)
autoplot(result_ts)+autolayer(quotes_bitcoin)
autoplot(result_ts)
autolayer(quotes_bitcoin)
autoplot(quotes_bitcoin)
tbind <- rbind(result_ts, quotes_bitcoin)
View(tbind)
autoplot(tbind)
autoplot(result_ts)
autoplot(tbind)
autoplot(result_ts)+autolayer(quotes_bitcoin)
autoplot(result_ts)+autolayer(ts(quotes_bitcoin)
)
autoplot(result_ts)+autolayer(ts(quotes_bitcoin))
result_ts
quotes_bitcoin
colnames(result_ts)[1] <- "Close"
result_ts
autoplot(result_ts)+autolayer(ts(quotes_bitcoin))
autoplot(ts(result_ts))+autolayer(ts(quotes_bitcoin))
autoplot(ts(result_ts))+autolayer(ts(quotes_bitcoin),series="Actual")
autoplot(ts(results))+autolayer(ts(quotes_bitcoin),series="Actual")
autoplot(ts(results$Close))+autolayer(ts(quotes_bitcoin),series="Actual")
hh <- 1966
# Create a vector to store the forecasts
forecasts_without_reestimation <- numeric(hh)
results <- data.frame(Date = integer(hh), Close = integer(hh))
# Forecasting step-by-step without re-estimation
for (i in 1:hh) {
# Forecast the next period using the already fitted model
if (i==1) {
arima_model_500test <- Arima(log_transformed_500$Close, order=c(4,1,0))
} else {
arima_model_500test <- Arima(rbind(log_transformed_500,log(quotes_bitcoin[500+(i-1)]))$Close, order=c(4,1,0))
}
forecast_result <- forecast(arima_model_500test, h=1)
results$Date[i] <- as.character.Date(index(quotes_bitcoin)[500+i])
results$Close[i] <- forecast_result$mean[1]
# Store the forecast for the i-th period
forecasts_without_reestimation[i] <- forecast_result$mean[1]
}
View(results)
autoplot(ts(results$Close))+autolayer(ts(quotes_bitcoin),series="Actual")
autoplot(ts(results$Close))+autolayer(ts(log(quotes_bitcoin)),series="Actual")
autoplot(ts(results))+autolayer(ts(log(quotes_bitcoin)),series="Actual")
help("autoplot")
autoplot(ts(forecasts_without_reestimation)) + autolayer(ts(log_transformed_1966), series="Actual")
length(forecasts_without_reestimation)
autoplot(ts(forecasts_without_reestimation)) + autolayer(ts(log(quotes_bitcoin)), series="Actual")
autoplot(rbind(forecasts_without_reestimation,log(quotes_bitcoin))) + autolayer(ts(log(quotes_bitcoin)), series="Actual")
autoplot(rbind(forecasts_without_reestimation,log(quotes_bitcoin)$Close)) + autolayer(ts(log(quotes_bitcoin)), series="Actual")
autoplot(ts(forecasts_without_reestimation+log(quotes_bitcoin)$Close)) + autolayer(ts(log(quotes_bitcoin)), series="Actual")
autoplot(bind(forecasts_without_reestimation,log(quotes_bitcoin))$Close) + autolayer(ts(log(quotes_bitcoin)), series="Actual")
autoplot(rbind(forecasts_without_reestimation,log(quotes_bitcoin))$Close) + autolayer(ts(log(quotes_bitcoin)), series="Actual")
autoplot(rbind(forecasts_without_reestimation,log(quotes_bitcoin))) + autolayer(ts(log(quotes_bitcoin)), series="Actual")
length(quotes_bitcoin)
hh <- 1966
# Create a vector to store the forecasts
forecasts_without_reestimation <- numeric(2466)
forecasts_without_reestimation <- log_transformed_500
View(forecasts_without_reestimation)
# Create a vector to store the forecasts
forecasts_without_reestimation <- numeric(2466)
log_transformed_500[1]
log_transformed_500$Close[1]
as.Double(log_transformed_500$Close[1])
as.double(log_transformed_500$Close[1])
hh <- 1966
# Create a vector to store the forecasts
forecasts_without_reestimation <- numeric(2466)
for(k in 1:500) {
forecasts_without_reestimation[k] <- as.double(log_transformed_500$Close[k])
}
results <- data.frame(Date = integer(2466), Close = integer(2466))
# Forecasting step-by-step without re-estimation
for (i in 1:hh) {
# Forecast the next period using the already fitted model
if (i==1) {
arima_model_500test <- Arima(log_transformed_500$Close, order=c(4,1,0))
} else {
arima_model_500test <- Arima(rbind(log_transformed_500,log(quotes_bitcoin[500+(i-1)]))$Close, order=c(4,1,0))
}
forecast_result <- forecast(arima_model_500test, h=1)
results$Date[i] <- as.character.Date(index(quotes_bitcoin)[500+i])
results$Close[i] <- forecast_result$mean[1]
# Store the forecast for the i-th period
forecasts_without_reestimation[500+i] <- forecast_result$mean[1]
}
autoplot(forecasts_without_reestimation) + autolayer(ts(log(quotes_bitcoin)), series="Actual")
View(arima_forecast_500)
autoplot(ts(forecasts_without_reestimation) + autolayer(ts(log(quotes_bitcoin)), series="Actual")
)
autoplot(ts(forecasts_without_reestimation)) + autolayer(ts(log(quotes_bitcoin)), series="Actual")
accuracy(forecasts_without_reestimation, log_transformed_1966)
accuracy(forecasts_without_reestimation, log(quotes_bitcoin))
